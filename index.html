<!DOCTYPE html>

<html>

  <head>

<style>
      body { margin: 0; overflow: hidden; font-family: 'Courier New', sans-serif; cursor: crosshair; }
      
      /* THE SYSTEM UI CONTAINER - Positioned Bottom Left */
      #system-ui {
        position: absolute; 
        bottom: 20px; 
        left: 20px;
        width: 300px;
        background: rgba(0, 10, 30, 0.85); 
        border: 2px solid #00aaff; 
        box-shadow: 0 0 15px #00aaff;
        padding: 15px;
        border-radius: 5px;
        color: white;
        pointer-events: none; 
        z-index: 100;
      }

      /* TEXT STYLES */
      h2 { margin: 0 0 5px 0; color: #00aaff; font-size: 16px; letter-spacing: 1px; }
      .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-weight: bold; }
      
      /* BARS */
      .bar-container {
        width: 100%; height: 10px; background: #222; margin-bottom: 8px; border: 1px solid #444;
      }
      .bar-fill { height: 100%; transition: width 0.2s; }
      
      #hp-bar { background: #ff3333; width: 100%; }   /* Red */
      #mana-bar { background: #00d2ff; width: 100%; } /* Light Blue */
      #xp-bar { background: #ffaa00; width: 0%; }     /* Gold */

      /* OLD CONTROLS HINT */
      #controls-hint {
        margin-top: 10px; font-size: 11px; color: #aaa; border-top: 1px solid #444; padding-top: 5px;
      }
      .active-status { color: #55ff55 !important; }

     /* MINIMAP UI */
      #minimap {
        position: absolute; 
        top: 20px; 
        right: 20px;
        width: 200px; 
        height: 200px;
        /* NEW: Paints the 4 biomes as a pie chart! */
        background: conic-gradient(
          from 90deg, 
          #2a0f0f 0deg 90deg,   /* Volcano (Bottom Right) */
          #150025 90deg 180deg, /* darkness (Bottom Left) */
          #d0e6f5 180deg 270deg,/* Sky (Top Left) */
          #3b2a1a 270deg 360deg /* Earth (Top Right) */
        );
        border: 2px solid #00aaff; 
        border-radius: 50%; /* Circular */
        box-shadow: 0 0 15px #00aaff;
        z-index: 100;
        overflow: hidden;
      }
      
      /* Center Forest Zone Indicator */
      #minimap::after {
        content: ''; 
        position: absolute;
        top: 40%; left: 40%; 
        width: 20%; height: 20%;
        background: #2d4c1e; /* Solid green center */
        border-radius: 50%;
        box-shadow: 0 0 10px #000;
      }

      /* The Player Cursor (Yellow Arrow) */
      #player-cursor {
        position: absolute; 
        width: 0; height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-bottom: 14px solid #ffffff; 
        margin-left: -6px; margin-top: -7px; /* Centers the arrow */
        transition: transform 0.1s; /* Smooth turning */
        z-index: 10; /* NEW: Forces the arrow to draw ON TOP of the biomes */
      }
#toggle-menu-btn {
    position: absolute;
    bottom: 220px; /* Increased from 100px to sit safely above the stats */
    left: 20px;
    padding: 10px 20px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    z-index: 1000;
}

/* The Main Menu Window */
#game-menu {
    display: none; /* Hidden until you click MENU */
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 600px;
    height: 400px;
    background: rgba(10, 10, 20, 0.9);
    border: 2px solid #555;
    color: white;
    z-index: 999;
    padding: 20px;
    border-radius: 8px;
    font-family: sans-serif;
}

/* Tab Layout */
#menu-tabs {
    display: flex;
    gap: 10px;
    border-bottom: 2px solid #555;
    padding-bottom: 10px;
    margin-bottom: 20px;
}

.menu-tab {
    padding: 8px 16px;
    cursor: pointer;
    background: #333;
    color: white;
    border: none;
    border-radius: 4px;
}

.inv-categories {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}
    </style>

    <script type="importmap">

      {

        "imports": {

          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"

        }

      }

    </script>

  </head>

  <body>

    <div id="system-ui">
      <div class="stat-row">
        <h2>STATUS</h2>
        <span>LVL <span id="level-val">1</span></span>
      </div>
      
      <div style="font-size: 12px; margin-top: 5px;">HP <span id="hp-text" style="float:right;">100/100</span></div>
      <div class="bar-container">
        <div id="hp-bar" class="bar-fill"></div>
      </div>

      <div style="font-size: 12px;">MANA <span id="mana-text" style="float:right;">100/100</span></div>
      <div class="bar-container">
        <div id="mana-bar" class="bar-fill"></div>
      </div>

      <div style="font-size: 12px;">EXP <span id="xp-text" style="float:right;">0/80</span></div>
      <div class="bar-container" style="margin-bottom: 0;">
        <div id="xp-bar" class="bar-fill"></div>
      </div>

      <div id="controls-hint">
        <span id="status" style="color:#ff5555; font-weight:bold;">Shift Lock: OFF</span><br>
        <b>Shift</b> Lock | <b>WASD</b> Move | <b>Q</b> Dash
      </div>
    </div>

    <div id="minimap">
        <div id="player-cursor"></div>
    </div>

    <button id="toggle-menu-btn">MENU</button>

<div id="game-menu">
    <div id="menu-tabs">
        <button class="menu-tab" onclick="switchTab('stats')">Stats</button>
        <button class="menu-tab" onclick="switchTab('inventory')">Inventory</button>
        <button class="menu-tab" onclick="switchTab('quests')">Daily Quests</button>
    </div>
    
    <div id="tab-stats" class="tab-content">
        <h2>Stats</h2>
        <p>Available Stat Points: 0</p>
        <p><em>(Leveling system coming soon!)</em></p>
    </div>

    <div id="tab-inventory" class="tab-content" style="display: none;">
        <h2>Inventory</h2>
        <div class="inv-categories">
            <button>Materials</button>
            <button>Armor</button>
            <button>Weapons</button>
        </div>
        <div class="inv-items">
            <p>Your inventory is empty.</p>
        </div>
    </div>

    <div id="tab-quests" class="tab-content" style="display: none;">
        <h2>Daily Quests</h2>
        <p>Nothing here right now. Check back later!</p>
    </div>
</div>

    <script type="module">

      import * as THREE from 'three';



      let camera, scene, renderer;

     

      // Movement & Looking States

      let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

      let lookUp = false, lookDown = false, lookLeft = false, lookRight = false;

     

      // Jump & Dash Variables

      let velocityY = 0;

      let canJump = true;

      let dashTriggered = false;

      let dashCooldown = 0;

     

      // Avatar & Particles

      let player;
      const particles = [];
      let prevTime = performance.now();
      const worldMeshes = []; // List of things we can stand on
      const raycaster = new THREE.Raycaster(); // Collision detector
      // Camera Rotation Variables
      let yaw = 0;
      let pitch = 0;
      let previousMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      // Shift Lock State
      let isShiftLocked = false;
      // RPG Stats
      let level = 1;
      let currentHp = 100;
      let maxHp = 100;
      let currentMana = 100;
      let maxMana = 100;
      let currentXp = 0;
      let maxXp = 80;
      const statusElement = document.getElementById('status');
      let isSprinting = false;
      let enemies = []; // Stores all active enemies
      let isTargeting = false;
const RENDER_RADIUS = 1500; // If you are further than this, the enemy "vanishes"

const biomeData = {
    forest: {
        center: { x: 0, z: 0 },
        spawn: { minR: 250, maxR: 1750, startA: 0, endA: Math.PI * 2 },
        mobs: [
            { name: "Slime", color: 0x00ff00, size: 2, hp: 10, exp: 5 },
            { name: "Goblin", color: 0x228b22, size: 3, hp: 25, exp: 12 },
            { name: "Spitter", color: 0xadff2f, size: 3.5, hp: 45, exp: 25 },
            { name: "Treant", color: 0x8b4513, size: 5, hp: 80, exp: 50 },
            { name: "Gargoyle", color: 0x556b2f, size: 6, hp: 120, exp: 80 }
        ],
        boss: { name: "Forest Guardian", color: 0x003300, size: 12, hp: 1000, exp: 500 }
    },
    earth: {
        center: { x: 6000 * Math.cos(Math.PI/4), z: 6000 * Math.sin(Math.PI/4) },
        spawn: { minR: 2200, maxR: 9500, startA: 0, endA: Math.PI / 2 },
        mobs: [
            { name: "Mud Crab", color: 0x8b7355, size: 2.5, hp: 15, exp: 8 },
            { name: "Rock Grunt", color: 0x696969, size: 3.5, hp: 35, exp: 18 },
            { name: "Sandworm", color: 0xd2b48c, size: 4, hp: 60, exp: 35 },
            { name: "Golem", color: 0x808080, size: 6, hp: 100, exp: 65 },
            { name: "Earth Elemental", color: 0x5c4033, size: 7, hp: 150, exp: 100 }
        ],
        boss: { name: "Earth Titan", color: 0x3b2a1a, size: 15, hp: 1500, exp: 800 }
    },
    sky: {
        center: { x: 6000 * Math.cos(3*Math.PI/4), z: 6000 * Math.sin(3*Math.PI/4) },
        spawn: { minR: 2200, maxR: 9500, startA: Math.PI / 2, endA: Math.PI },
        mobs: [
            { name: "Wisp", color: 0xe0ffff, size: 2, hp: 12, exp: 6 },
            { name: "Harpy", color: 0xadd8e6, size: 3, hp: 30, exp: 15 },
            { name: "Gale Flyer", color: 0x87cefa, size: 4, hp: 55, exp: 30 },
            { name: "Storm Cloud", color: 0x778899, size: 5, hp: 90, exp: 60 },
            { name: "Wind Elemental", color: 0x4682b4, size: 6, hp: 140, exp: 90 }
        ],
        boss: { name: "Sky Dragon", color: 0x00008b, size: 14, hp: 1300, exp: 700 }
    },
    darkness: {
        center: { x: 6000 * Math.cos(5*Math.PI/4), z: 6000 * Math.sin(5*Math.PI/4) },
        spawn: { minR: 2200, maxR: 9500, startA: Math.PI, endA: Math.PI * 1.5 },
        mobs: [
            { name: "Shadow", color: 0x111111, size: 2, hp: 20, exp: 10 },
            { name: "Skeleton", color: 0xdddddd, size: 3, hp: 45, exp: 22 },
            { name: "Wraith", color: 0x4b0082, size: 4, hp: 75, exp: 45 },
            { name: "Void Crawler", color: 0x2f4f4f, size: 5, hp: 120, exp: 75 },
            { name: "Reaper", color: 0x000000, size: 6.5, hp: 180, exp: 120 }
        ],
        boss: { name: "Necromancer", color: 0x2a004d, size: 12, hp: 2000, exp: 1000 }
    },
    volcano: {
        center: { x: 6000 * Math.cos(7*Math.PI/4), z: 6000 * Math.sin(7*Math.PI/4) },
        spawn: { minR: 2200, maxR: 9500, startA: Math.PI * 1.5, endA: Math.PI * 2 },
        mobs: [
            { name: "Fire Bat", color: 0xff4500, size: 2, hp: 25, exp: 12 },
            { name: "Magma Slime", color: 0xff8c00, size: 3, hp: 50, exp: 25 },
            { name: "Ash Walker", color: 0xa9a9a9, size: 4, hp: 85, exp: 50 },
            { name: "Hellhound", color: 0x8b0000, size: 5, hp: 130, exp: 85 },
            { name: "Fire Giant", color: 0xb22222, size: 7, hp: 200, exp: 150 }
        ],
        boss: { name: "Demon Lord", color: 0x4a0000, size: 16, hp: 2500, exp: 1500 }
    }
};
      init();
      animate();


      function init() {
        // 1. Setup Scene (Pushed fog back to 5000 units for the massive map)
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 0, 5000);

        // 2. Setup Camera (Far clipping plane increased to 50000)
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 50000);
        camera.position.set(0, 10, 0);
        camera.rotation.order = 'YXZ';

        // 3. Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0x444444);
        scene.add(light);
        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(0, 200, 100);
        scene.add(dirLight);

        // 5. Generate Environment
        generateEnvironment();
        spawnEntities();
        createAvatar(); // Build the player

        // 6. Mouse Look Controls
        document.addEventListener('mousemove', (e) => {
            // e.movementX works perfectly whether the mouse is locked or not!
            const deltaX = e.movementX || 0;
            const deltaY = e.movementY || 0;

            yaw -= deltaX * 0.005;  
            pitch -= deltaY * 0.005;
            
            // Stop the camera from flipping upside down
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

            // Update camera rotation
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        });

        // 7. Keyboard Controls
        const onKeyDown = (event) => {
         // Toggle Shift Lock with Z
          if (event.code === 'KeyZ') {
            // 1. Lock the mouse so you don't hit the screen edge
            if (document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            }

            isShiftLocked = !isShiftLocked;
            // Update UI text and color
            if (isShiftLocked) {
              statusElement.innerText = "Shift Lock: ON";
              statusElement.classList.add('active-status');
            } else {
              statusElement.innerText = "Shift Lock: OFF";
              statusElement.classList.remove('active-status');
            }
            return;
          }

          // Movement & Actions
          switch (event.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyD': moveRight = true; break;

            case 'ControlLeft': 
            case 'ControlRight': 
              isSprinting = !isSprinting; // Flips between true and false!
              break;

            // Jump and Dash
            case 'Space':
              if (canJump) {
                  velocityY = 30; // Jump Power
                  canJump = false;
              }
              break;

           case 'KeyQ':
              // Only dash if we have 10 or more Mana and the cooldown is ready
              if (dashCooldown <= 0 && currentMana >= 10) {
                  dashTriggered = true; 
                  currentMana -= 10; // Drain 10 Mana!
              }
              break;

            // Arrow Keys for looking
            case 'ArrowUp': lookUp = true; break;
            case 'ArrowDown': lookDown = true; break;
            case 'ArrowLeft': lookLeft = true; break;
            case 'ArrowRight': lookRight = true; break;

           // Minimap Toggle (Now Expands instead of Hiding)
            case 'KeyM':
                const mapEl = document.getElementById('minimap');
                
                // Check if it already has our custom 'expanded' label
                if (!mapEl.classList.contains('expanded')) {
                    // EXPAND MAP: Center it and make it 2.5x bigger
                    mapEl.classList.add('expanded');
                    mapEl.style.position = 'absolute';
                    mapEl.style.left = '50%';
                    mapEl.style.top = '50%';
                    // translate centers it, scale makes it bigger!
                    mapEl.style.transform = 'translate(-50%, -50%) scale(2.5)'; 
                    mapEl.style.transformOrigin = 'center center';
                    mapEl.style.zIndex = '1000'; // Ensure it pops over everything else
                } else {
                    // SHRINK MAP: Clear the styles so it snaps back to your CSS corner
                    mapEl.classList.remove('expanded');
                    mapEl.style.position = '';
                    mapEl.style.left = '';
                    mapEl.style.top = '';
                    mapEl.style.transform = '';
                    mapEl.style.transformOrigin = '';
                    mapEl.style.zIndex = '';
                }
                break;
          } 
        };

        const onKeyUp = (event) => {
          switch (event.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyD': moveRight = false; break;

            case 'ArrowUp': lookUp = false; break;
            case 'ArrowDown': lookDown = false; break;
            case 'ArrowLeft': lookLeft = false; break;
            case 'ArrowRight': lookRight = false; break;
          }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // 8. Renderer Setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        window.addEventListener('resize', onWindowResize);
      }

// --- TEXTURE GENERATOR ---
      function createTexture(baseColor, speckColor) {
          const canvas = document.createElement('canvas');
          canvas.width = 256; 
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
                    // Fill base color
          ctx.fillStyle = baseColor;
          ctx.fillRect(0, 0, 256, 256);
          
          // Add detailed noise/specks
          ctx.fillStyle = speckColor;
          for(let i = 0; i < 1500; i++) {
              ctx.fillRect(Math.random() * 256, Math.random() * 256, Math.random() * 3, Math.random() * 3);
          }
          
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(2, 2);
          return texture;
      }

 function generateEnvironment() {
        // --- TEXTURE GENERATOR HELPER ---
        function createTexture(baseColor, speckColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; 
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 256, 256);
            
            ctx.fillStyle = speckColor;
            for(let i = 0; i < 1500; i++) {
                ctx.fillRect(Math.random() * 256, Math.random() * 256, Math.random() * 3, Math.random() * 3);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10); 
            return texture;
        }

        // --- THE OPTIMIZER OBJECT ---
        // This invisible dummy calculates the math before stamping it into the GPU
        const dummy = new THREE.Object3D();

        // --- 1. BUILD MASSIVE CIRCULAR MAP (5x Scale) ---
        const forestGeo = new THREE.CircleGeometry(2000, 64);
        const forestMat = new THREE.MeshStandardMaterial({ map: createTexture('#2d4c1e', '#1a2e11'), roughness: 0.9 }); 
        const forest = new THREE.Mesh(forestGeo, forestMat);
        forest.rotation.x = -Math.PI / 2;
        scene.add(forest);
        worldMeshes.push(forest); 

        function createWedge(baseColor, speckColor, startAngle, depth = 0) {
            const geo = new THREE.RingGeometry(2000, 10000, 64, 1, startAngle, Math.PI / 2);
            const mat = new THREE.MeshStandardMaterial({ map: createTexture(baseColor, speckColor), roughness: 0.9 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y = depth;
            scene.add(mesh);
            worldMeshes.push(mesh);
        }

        function spawnProps(minR, maxR, startAngle, count, callback) {
            for (let i = 0; i < count; i++) {
                const radius = minR + Math.random() * (maxR - minR);
                const angle = startAngle + Math.random() * (Math.PI / 2); 
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                callback(x, z);
            }
        }

        createWedge('#3b2a1a', '#2a1a0c', 0);                    // Earth 
        createWedge('#d0e6f5', '#a0c6e5', Math.PI / 2);          // Sky 
        createWedge('#150025', '#0a0011', Math.PI, 0);           // Darkness 
        createWedge('#2a0f0f', '#1a0505', Math.PI * 1.5);        // Volcano        

        // --- 2. FOREST (Instanced Trees) ---
        const woodMat = new THREE.MeshStandardMaterial({ map: createTexture('#4a3018', '#2a1a0c'), roughness: 1.0 });
        const leafMat = new THREE.MeshStandardMaterial({ map: createTexture('#1e3f14', '#2d5c1e'), roughness: 0.8 });
        
        const treeCount = 2500;
        const trunkGeo = new THREE.CylinderGeometry(2, 3, 1, 8); // Height is 1 so we can scale it
        const leafGeo = new THREE.DodecahedronGeometry(1); // Size is 1 so we can scale it
        
        const iTrunks = new THREE.InstancedMesh(trunkGeo, woodMat, treeCount);
        const iLeaves = new THREE.InstancedMesh(leafGeo, leafMat, treeCount);

        let treeIndex = 0;
        for(let i=0; i<6000; i++) {
            if (treeIndex >= treeCount) break;
            const x = (Math.random() - 0.5) * 3800; 
            const z = (Math.random() - 0.5) * 3800;
            if (Math.sqrt(x*x + z*z) > 1900) continue; 
            
            const h = 20 + Math.random() * 30;
            const leafSize = 10 + Math.random() * 5;
            
            // Trunk
            dummy.position.set(x, h/2, z);
            dummy.scale.set(1, h, 1);
            dummy.rotation.set(0, 0, 0);
            dummy.updateMatrix();
            iTrunks.setMatrixAt(treeIndex, dummy.matrix);

            // Leaves
            dummy.position.set(x, h, z);
            dummy.scale.set(leafSize, leafSize, leafSize);
            dummy.updateMatrix();
            iLeaves.setMatrixAt(treeIndex, dummy.matrix);

            treeIndex++;
        }
        scene.add(iTrunks, iLeaves); 
        worldMeshes.push(iTrunks); 

        // --- 3. VOLCANO (Instanced Obsidian Spikes) ---
        const obsMat = new THREE.MeshStandardMaterial({ map: createTexture('#111111', '#333333'), roughness: 0.5, metalness: 0.8 });
        const spikeCount = 600;
        const iSpikes = new THREE.InstancedMesh(new THREE.TetrahedronGeometry(40), obsMat, spikeCount);
        
        let spikeIdx = 0;
        spawnProps(2200, 9500, 0, spikeCount, (x, z) => {
            dummy.position.set(x, 10, z);
            dummy.scale.set(1, 4 + Math.random() * 8, 1);
            dummy.rotation.set(0, Math.random() * Math.PI, 0);
            dummy.updateMatrix();
            iSpikes.setMatrixAt(spikeIdx, dummy.matrix);
            spikeIdx++;
        });
        scene.add(iSpikes); 
        worldMeshes.push(iSpikes);

        // --- 4. DARKNESS (Instanced Monoliths & Crystals) ---
        const monolithMat = new THREE.MeshStandardMaterial({ map: createTexture('#05000a', '#222222'), roughness: 0.7 }); 
        const monoCount = 800;
        const iMonoliths = new THREE.InstancedMesh(new THREE.BoxGeometry(20, 1, 20), monolithMat, monoCount);
        
        // Setup two separate instanced meshes for the two different glowing crystal colors
        const crystGeo = new THREE.OctahedronGeometry(1);
        const cMat1 = new THREE.MeshStandardMaterial({ map: createTexture('#aa00ff', '#ffffff'), emissive: 0xaa00ff, emissiveIntensity: 0.5 });
        const cMat2 = new THREE.MeshStandardMaterial({ map: createTexture('#5500aa', '#ffffff'), emissive: 0x5500aa, emissiveIntensity: 0.5 });
        const iCryst1 = new THREE.InstancedMesh(crystGeo, cMat1, monoCount);
        const iCryst2 = new THREE.InstancedMesh(crystGeo, cMat2, monoCount);

        let monoIdx = 0, cIdx1 = 0, cIdx2 = 0;
        
        spawnProps(2200, 9500, Math.PI / 2, monoCount, (x, z) => {
            const height = 30 + Math.random() * 100; 
            dummy.position.set(x, height/2, z);
            dummy.scale.set(1, height, 1);
            dummy.rotation.set(0, 0, 0);
            dummy.updateMatrix();
            iMonoliths.setMatrixAt(monoIdx, dummy.matrix);
            monoIdx++;

            if (Math.random() > 0.5) {
                const size = 8 + Math.random() * 10;
                dummy.position.set(x + (Math.random() * 30 - 15), 5, z + (Math.random() * 30 - 15));
                dummy.scale.set(size, size, size);
                dummy.rotation.set(Math.random(), Math.random(), 0);
                dummy.updateMatrix();
                
                if (Math.random() > 0.5) {
                    iCryst1.setMatrixAt(cIdx1, dummy.matrix);
                    cIdx1++;
                } else {
                    iCryst2.setMatrixAt(cIdx2, dummy.matrix);
                    cIdx2++;
                }
            }
        });
        
        // Trim the empty slots in the crystal arrays so the GPU doesn't draw invisible objects
        iCryst1.count = cIdx1; 
        iCryst2.count = cIdx2;
        
        scene.add(iMonoliths, iCryst1, iCryst2); 
        worldMeshes.push(iMonoliths, iCryst1, iCryst2);

        // --- 5. SKY (Instanced Floating Platforms) ---
        const cloudMat = new THREE.MeshStandardMaterial({ map: createTexture('#ffffff', '#e0e0e0'), roughness: 1.0 });
        const islandCount = 600;
        const iIslands = new THREE.InstancedMesh(new THREE.CylinderGeometry(80, 30, 15, 16), cloudMat, islandCount);
        
        let islandIdx = 0;
        spawnProps(2200, 9500, Math.PI, islandCount, (x, z) => {
            dummy.position.set(x, 50 + Math.random() * 300, z);
            dummy.scale.set(1, 1, 1);
            dummy.rotation.set(0, 0, 0);
            dummy.updateMatrix();
            iIslands.setMatrixAt(islandIdx, dummy.matrix);
            islandIdx++;
        });
        scene.add(iIslands); 
        worldMeshes.push(iIslands);

        // --- 6. EARTH (Instanced Giant Crystals & Craters) ---
        const mudMat = new THREE.MeshStandardMaterial({ map: createTexture('#6b4423', '#4a2f18'), roughness: 0.9 });
        const rockCount = 800;
        const iRocks = new THREE.InstancedMesh(new THREE.OctahedronGeometry(60), mudMat, rockCount);
        
        let rockIdx = 0;
        spawnProps(2200, 9500, Math.PI * 1.5, rockCount, (x, z) => {
            dummy.position.set(x, 20, z);
            dummy.scale.set(1, 1, 1);
            dummy.rotation.set(Math.random(), Math.random(), 0);
            dummy.updateMatrix();
            iRocks.setMatrixAt(rockIdx, dummy.matrix);
            rockIdx++;
        });
        scene.add(iRocks); 
        worldMeshes.push(iRocks);

        // --- 7. BUILD THEMED TEMPLES (Boss Arenas) ---
        for (const biomeName in biomeData) {
            const biome = biomeData[biomeName];
            const templeParts = [];

            // 1. Determine Theme Colors based on Biome
            let matColor = 0x888888;
            if (biomeName === 'Forest') matColor = 0x557755;   // Mossy stone
            if (biomeName === 'Volcano') matColor = 0x221111;  // Dark obsidian
            if (biomeName === 'Darkness') matColor = 0x1a0033; // Deep purple stone
            if (biomeName === 'Sky') matColor = 0xeeeeee;      // White marble
            if (biomeName === 'Earth') matColor = 0x8b5a2b;    // Sandstone

            // 2. Foundation (Raised platform: 160x160, 10 units tall)
            const foundation = new THREE.BoxGeometry(160, 10, 160);
            foundation.translate(0, 5, 0);
            templeParts.push(foundation);

            // 3. Stairs (Front entrance, leading up to the door)
            for (let i = 0; i < 5; i++) {
                const step = new THREE.BoxGeometry(40, 2, 10);
                // Math to stack them like real stairs
                step.translate(0, i * 2 + 1, 85 + (4 - i) * 10); 
                templeParts.push(step);
            }

            // 4. Walls (Leaving the front open for a door)
            const wallThick = 10;
            const wallH = 40;
            
            const backWall = new THREE.BoxGeometry(160, wallH, wallThick);
            backWall.translate(0, 10 + wallH/2, -75);
            templeParts.push(backWall);
            
            const leftWall = new THREE.BoxGeometry(wallThick, wallH, 160);
            leftWall.translate(-75, 10 + wallH/2, 0);
            templeParts.push(leftWall);
            
            const rightWall = new THREE.BoxGeometry(wallThick, wallH, 160);
            rightWall.translate(75, 10 + wallH/2, 0);
            templeParts.push(rightWall);
            
            // Front walls (leaving a 40-unit gap in the middle for the entrance)
            const frontWallL = new THREE.BoxGeometry(60, wallH, wallThick);
            frontWallL.translate(-50, 10 + wallH/2, 75);
            templeParts.push(frontWallL);
            
            const frontWallR = new THREE.BoxGeometry(60, wallH, wallThick);
            frontWallR.translate(50, 10 + wallH/2, 75);
            templeParts.push(frontWallR);

            // 5. Roof (Tiered pyramid style)
            const roof1 = new THREE.BoxGeometry(170, 5, 170);
            roof1.translate(0, 10 + wallH + 2.5, 0);
            templeParts.push(roof1);
            
            const roof2 = new THREE.BoxGeometry(150, 10, 150);
            roof2.translate(0, 10 + wallH + 10, 0);
            templeParts.push(roof2);

            // 6. Merge everything into ONE highly optimized mesh
            const mergedTempleGeo = BufferGeometryUtils.mergeGeometries(templeParts);
            const templeMat = new THREE.MeshStandardMaterial({ color: matColor, roughness: 0.9 });
            const finalTemple = new THREE.Mesh(mergedTempleGeo, templeMat);

            // Move the whole structure to the biome center
            finalTemple.position.set(biome.center.x, 0, biome.center.z);
            
            // Rotate the temple so the stairs face the center of the map (0,0)
            finalTemple.lookAt(0, 0, 0);

            scene.add(finalTemple);
            worldMeshes.push(finalTemple); // Adds the walls, floor, and stairs to collision!
        }
      }

      function spawnEntities() {
        for (const biomeName in biomeData) {
            const biome = biomeData[biomeName];

            // 1. Spawn the Boss INSIDE the Temple (Now a Cube!)
            const bossGeo = new THREE.BoxGeometry(biome.boss.size, biome.boss.size, biome.boss.size);
            const bossMat = new THREE.MeshStandardMaterial({ 
                color: biome.boss.color, 
                emissive: biome.boss.color, 
                emissiveIntensity: 0.2 
            });
            const bossMesh = new THREE.Mesh(bossGeo, bossMat);
            
            // Y is set to 2 (floor height) + half the boss size so it doesn't sink into the ground
            bossMesh.position.set(biome.center.x,10  + (biome.boss.size / 2), biome.center.z);
            
            // Hide by default for your optimizer
            bossMesh.visible = false;
            scene.add(bossMesh);
            enemies.push({ ...biome.boss, mesh: bossMesh, type: "boss", active: false });

            // 2. Spawn 30 of each normal mob in this biome
            biome.mobs.forEach(mobData => {
                for (let i = 0; i < 30; i++) {
                    const radius = biome.spawn.minR + Math.random() * (biome.spawn.maxR - biome.spawn.minR);
                    const angle = biome.spawn.startA + Math.random() * (biome.spawn.endA - biome.spawn.startA);
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    const mobGeo = new THREE.BoxGeometry(mobData.size, mobData.size, mobData.size);
                    const mobMat = new THREE.MeshStandardMaterial({ color: mobData.color });
                    const mobMesh = new THREE.Mesh(mobGeo, mobMat);
                    
                    mobMesh.position.set(x, mobData.size / 2, z);
                    
                    // Hide them by default to save CPU!
                    mobMesh.visible = false; 
                    scene.add(mobMesh);
                    
                    enemies.push({ ...mobData, mesh: mobMesh, type: "mob", active: false });
                }
            });
        }
      }
      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

      }
      function updateUI() {
        // Update Text
        document.getElementById('level-val').innerText = level;
        document.getElementById('hp-text').innerText = Math.floor(currentHp) + "/" + maxHp;
        document.getElementById('mana-text').innerText = Math.floor(currentMana) + "/" + maxMana;
        document.getElementById('xp-text').innerText = Math.floor(currentXp) + "/" + maxXp;

        // Update Bar Widths
        document.getElementById('hp-bar').style.width = (currentHp / maxHp) * 100 + "%";
        document.getElementById('mana-bar').style.width = (currentMana / maxMana) * 100 + "%";
        document.getElementById('xp-bar').style.width = (currentXp / maxXp) * 100 + "%";

        /// --- Update Minimap ---
        const mapEl = document.getElementById('minimap');
        
        // Removed the 'display === block' check because the map is always on now!
        if (player) {
            const cursor = document.getElementById('player-cursor');
            
            // Calculate Position (World is 40,000 wide! Scale = 0.005)
            const mapX = (player.position.x * 0.01) + 100;
            const mapZ = (player.position.z * 0.01) + 100; 
            
            cursor.style.left = Math.max(0, Math.min(200, mapX)) + 'px';
            cursor.style.top = Math.max(0, Math.min(200, mapZ)) + 'px';
            
            const angleDeg = -(yaw * 180 / Math.PI); 
            cursor.style.transform = `rotate(${angleDeg}deg)`;
        }
      }

    function createAvatar() {
        player = new THREE.Group();

        // Materials
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // Yellow
        const shirtMat = new THREE.MeshStandardMaterial({ color: 0x0000FF }); // Blue
        const pantsMat = new THREE.MeshStandardMaterial({ color: 0x00FF00 }); // Green

        // 1. Torso (Boxy Chest)
        const torsoGeo = new THREE.BoxGeometry(1.5, 2, 1); 
        const torso = new THREE.Mesh(torsoGeo, shirtMat);
        torso.position.y = 2; 
        player.add(torso);

        // 2. Head (Round/Cylinder)
        const headGeo = new THREE.CylinderGeometry(0.6, 0.6, 1, 32);
        const head = new THREE.Mesh(headGeo, skinMat);
        head.position.y = 3.6; 
        player.add(head);

        // 3. Limbs (Smooth Cylinders with correct pivot points)
        const limbGeo = new THREE.CylinderGeometry(0.25, 0.25, 2.2, 16);
        limbGeo.translate(0, -1.1, 0); // Pivot at top

        const legGeo = new THREE.CylinderGeometry(0.3, 0.3, 2.2, 16);
        legGeo.translate(0, -1.1, 0); // Pivot at top

        // Arms
        player.lArm = new THREE.Mesh(limbGeo, skinMat);
        player.lArm.position.set(-1.0, 2.8, 0);
        player.add(player.lArm);

        player.rArm = new THREE.Mesh(limbGeo, skinMat);
        player.rArm.position.set(1.0, 2.8, 0); 
        player.add(player.rArm);

        // Legs
        player.lLeg = new THREE.Mesh(legGeo, pantsMat);
        player.lLeg.position.set(-0.4, 1, 0); 
        player.add(player.lLeg);

        player.rLeg = new THREE.Mesh(legGeo, pantsMat);
        player.rLeg.position.set(0.4, 1, 0); 
        player.add(player.rLeg);

        player.position.set(0, 10, 0);
        scene.add(player);
      }

     function animate() {
        requestAnimationFrame(animate);
        updateUI(); // Keep UI updated

        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;

        // --- RADIUS OPTIMIZER (CULLING) ---
        if (player) {
            enemies.forEach(enemy => {
                // Calculate distance from player to enemy
                const dx = player.position.x - enemy.mesh.position.x;
                const dz = player.position.z - enemy.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // If inside radius, wake them up!
                if (distance < RENDER_RADIUS) {
                    enemy.mesh.visible = true;
                    enemy.active = true;
                    
                    // (Later, we will put their movement/chasing code right here)
                    if (enemy.type === "mob" || enemy.type === "boss") {
                         enemy.mesh.rotation.y += 1 * delta; // Just spinning them slowly for now so you know they are alive
                    }
                } else {
                    // If outside radius, put them to sleep!
                    enemy.mesh.visible = false;
                    enemy.active = false;
                }
            });
        }

        // Check if we are actually moving and trying to sprint
        const isMoving = moveForward || moveBackward || moveLeft || moveRight;
        const actualSprinting = isSprinting && isMoving && currentMana > 0;

        // --- 1. Mana Regeneration & Drain ---
        if (actualSprinting) {
            // Drain 2 mana per second while running
            currentMana -= 2 * delta;
            if (currentMana < 0) currentMana = 0; 
        } else if (currentMana < maxMana) {
            // Only regenerate if NOT sprinting
            currentMana += 15 * delta; 
            if (currentMana > maxMana) currentMana = maxMana; 
        }

        // --- 2. Dash & Speed Logic ---
        if (dashCooldown > 0) dashCooldown -= delta;
        
        let baseSpeed = 20.0; // Normal walk speed
        if (actualSprinting) baseSpeed = 45.0; // Faster run speed
        
        if (dashTriggered) {
            baseSpeed = 600.0; 
            dashCooldown = 1.5;
            dashTriggered = false;

            // Particles
            for(let i=0; i<10; i++) {
                const pGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const pMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true });
                const p = new THREE.Mesh(pGeo, pMat);
                p.position.copy(player.position);
                p.position.y += 2; 
                p.position.x += (Math.random() - 0.5) * 2; 
                p.position.z += (Math.random() - 0.5) * 2; 
                scene.add(p);
                particles.push({ mesh: p, life: 1.0 });
            }
        }
        
        // Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.life -= delta * 2; 
            p.mesh.scale.multiplyScalar(0.95);
            p.mesh.rotation.x += 0.1;
            if (p.life <= 0) {
                scene.remove(p.mesh);
                particles.splice(i, 1);
            }
        }

      // --- 3. BIOME ATMOSPHERE & GRAVITY ---
        const distFromCenter = Math.sqrt(player.position.x * player.position.x + player.position.z * player.position.z);
        // The darkness now starts past 4000!
        const inDarknessBiome = (player.position.x < 0 && player.position.z > 0 && distFromCenter > 2000);

        velocityY -= 80.0 * delta; 
        if (dashTriggered) baseSpeed = 600.0; 
        
        if (inDarknessBiome) {
            scene.fog.color.setHex(0x3a1654); 
            scene.background.setHex(0x3a1654); 
            scene.fog.near = 0;
            scene.fog.far = 1500; // A bit further so you can see the giant monoliths
        } else {
            scene.fog.color.setHex(0x87CEEB); 
            scene.background.setHex(0x87CEEB);
            scene.fog.near = 0;
            scene.fog.far = 5000; // Let them see the massive world!
        }
        // --- 4. Collision (Floor & Ocean Bottom) ---
        const rayOrigin = player.position.clone();
        rayOrigin.y += 5; 
        raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0)); 

        const intersects = raycaster.intersectObjects(worldMeshes);
        let groundHeight = 0; // Solid ground everywhere by default

        if (intersects.length > 0) {
            if (intersects[0].point.y < player.position.y + 5) {
                groundHeight = intersects[0].point.y;
            }
        }

        player.position.y += velocityY * delta;

        if (player.position.y < groundHeight) { 
            player.position.y = groundHeight;
            velocityY = 0;
            canJump = true;
        }
// --- 5. ANIMATION (Walking & Sprinting) ---
        if (actualSprinting && !dashTriggered) {
            // NEW: Aggressive Running Animation
            const runCycle = Math.sin(time / 40) * 1.5; // Faster cycle, wider swings
            
            player.lLeg.rotation.x = runCycle;
            player.rLeg.rotation.x = -runCycle;
            player.lArm.rotation.x = -runCycle;
            player.rArm.rotation.x = runCycle;
            
            // Lean the entire body forward for a dramatic run
            player.rotation.x = -0.2; 
            
        } else if (isMoving && !dashTriggered) {
            // Normal Walking Animation
            const walkCycle = Math.sin(time / 60) * 0.8; 
            player.lLeg.rotation.x = walkCycle;
            player.rLeg.rotation.x = -walkCycle;
            player.lArm.rotation.x = -walkCycle;
            player.rArm.rotation.x = walkCycle;
            
            // Stand up straight
            player.rotation.x = 0;
        } else {
            // Standing Still
            player.lLeg.rotation.x = 0; player.rLeg.rotation.x = 0;
            player.lArm.rotation.x = 0; player.rArm.rotation.x = 0;
            player.rotation.x = 0;
        }
      // --- 6. Move Player & WALL COLLISION ---
        player.rotation.y = yaw;

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        direction.y = 0; 
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(new THREE.Vector3(0,1,0), direction).normalize();

        const moveSpeed = baseSpeed * delta;

        // NEW: Collision Checking Function
        // Casts a short ray from the player's chest in the direction they want to move
        function canMove(moveVector) {
            const chestHeight = new THREE.Vector3(player.position.x, player.position.y + 2, player.position.z);
            const moveRay = new THREE.Raycaster(chestHeight, moveVector.clone().normalize(), 0, 2.0); // 2.0 is your hitbox size
            const hits = moveRay.intersectObjects(worldMeshes);
            return hits.length === 0; // Returns true if nothing is blocking the way!
        }

        // Apply movement ONLY if the path is clear
        if (moveForward && canMove(direction)) player.position.addScaledVector(direction, moveSpeed);
        if (moveBackward && canMove(direction.clone().negate())) player.position.addScaledVector(direction, -moveSpeed);
        if (moveLeft && canMove(right.clone().negate())) player.position.addScaledVector(right, -moveSpeed);
        if (moveRight && canMove(right)) player.position.addScaledVector(right, moveSpeed);
       // --- 7. Update Camera ---
        if (isShiftLocked) {
            // ROBLOX MODE: Player turns with camera, over-the-shoulder view
            player.rotation.y = yaw; 
            
            camera.position.copy(player.position);
            camera.rotation.set(pitch, yaw, 0);
            camera.translateX(3);  // Shift right (over shoulder)
            camera.translateY(5);  // Move up
            camera.translateZ(10); // Move back
        } else {
            // FREE CAM MODE: Your original camera setup
            camera.position.copy(player.position);
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            camera.translateZ(20); 
            camera.translateY(6);
        }

        renderer.render(scene, camera);
      }
      const menuBtn = document.getElementById('toggle-menu-btn');
      const gameMenu = document.getElementById('game-menu');

      menuBtn.addEventListener('click', () => {
          if (gameMenu.style.display === 'none' || gameMenu.style.display === '') {
              gameMenu.style.display = 'block';
              menuBtn.innerText = 'BACK';
          } else {
              gameMenu.style.display = 'none';
              menuBtn.innerText = 'MENU';
          }
      });

      // Because you are using a module script, we have to attach this to 'window'
      // so the HTML buttons can find the function when clicked!
      window.switchTab = function(tabName) {
          document.getElementById('tab-stats').style.display = 'none';
          document.getElementById('tab-inventory').style.display = 'none';
          document.getElementById('tab-quests').style.display = 'none';
          document.getElementById('tab-' + tabName).style.display = 'block';
      };

    </script>

  </body>

</html>
